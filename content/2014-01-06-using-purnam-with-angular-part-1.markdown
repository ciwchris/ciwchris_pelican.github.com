Title: Using AngularJS with ClojureScript: Part 1
Date: 2014-01-06 15:48
Category: ClojureScript
Tags: clojurescript, angular
Slug: using-purnam-with-angular-part-1
Author: Chris
Summary: 


Being new to Clojure and ClojureScript my goal is to recreate the [Todo example](https://github.com/zcaudate/purnam-angular-example) using [Purnam](http://docs.caudate.me/purnam/), the JavaScript language extensions for ClojureScript, and also keep the scaffolding, dependency and build features which come with [yeoman](http://yeoman.io/).

### Creating the application

We will create a new ClojureScript project named todo using the leiningen template cljs-kickoff. This will setup up the project with ClojureScript using cljsbuild and Ring. Then we will generate an AngularJS application using yo, meaning the content generated by leiningen, in the resources public folder, will not be needed. We will therefore remove this content and link this folder to the app folder created by yo.

{% inline_code lang:console
$ lein new cljs-kickoff todo
$ cd todo
$ yo angular todo
Would you like to include Twitter Bootstrap? (Y/n) y
If so, would you like to use Twitter Bootstrap for Compass (as opposed to vanilla CSS)? (Y/n) n
Would you like to include angular-resource.js? (Y/n) n
Would you like to include angular-cookies.js? (Y/n) n
Would you like to include angular-sanitize.js? (Y/n) n
$ rm -rf resources/public
$ ln -s ~/todo/app ~/todo/resources/public
%}

### Configuring Karma

At the time of writing there appears to be some inconsistencies between the generated karama configuration and other yeoman tools. Therefore the following edits in karma.conf.js are needed.

{% inline_code lang:js karma.conf.js
// list of files / patterns to load in the browser
files: [
  'app/components/angular/angular.js',  // was: app/bower_components/angular/angular.js
  'app/components/angular-mocks/angular-mocks.js', // was: app/bower_components/angular/angular-mocks.js
  'app/scripts/*.js',
  'app/scripts/**/*.js',
  'test/mock/**/*.js',
  'test/spec/**/*.js'
],
%}

While we are here let's also turn on autoWatch and use PhantomJS as our browser.

{% inline_code lang:js karma.conf.js
autoWatch: true,

browsers: ['PhantomJS'],
%}

When running the Angular tests at this point, `grunt test`, I receive the error:

{% inline_code lang:console
Running "karma:unit" (karma) task
[2013-12-26 14:33:40.928] [ERROR] config - Invalid config file!
 [ReferenceError: module is not defined]
%}

This can be resolved by installing grunt-karma as a development dependency.

{% inline_code lang:console
$ npm install grunt-karma --save-dev
%}

Now when I run `grunt test` the test, which came with the angular project, will run and pass. Now that we know tests are running properly we can remove the JavaScript created by the angular scaffolding, since we will be using the JavaScript compiled from the ClojureScript we create.

{% inline_code lang:console
$ rm -rf app/scripts/*
$ rm -rf test/**/*.js
%}

### Creating the html

First we'll edit index.html. Since we are using ClojureScript we will compile all of our ClojureScript to a single JavaScript file. Therefore we'll only include a reference to app.js and remove the reference to the main controller. Let's also remove Google Analytics.

{% inline_code lang:html app/index.html

  <!-- build:js scripts/scripts.js -->
  <script src="scripts/app.js"></script>
  <!-- endbuild -->

</body>
%}

Next, let's update the view template, main.html. We'll start with displaying the number of todos.

{% inline_code lang:html app/views/main.html
<div class="centered">
  <h1>Todo List</h1>
  <span>{{remainingTodos()}} remaining</span>
</div>
%}

Finally, we'll update the Ring server handler to serve our index.html page.

{% inline_code lang:clj  src/clj/todo/server.clj
(defn handler [request]
  (if (= "/" (:uri request))
      (response/redirect "/index.html")))
%}

### Compiling ClojureScript

We need to make some change to the project file generated by leiningen. First add purnam as a dependency.

{% inline_code lang:clj project.clj
:dependencies [[org.clojure/clojure "1.5.1"]
               [org.clojure/clojurescript "0.0-1896"]
               [im.chit/purnam "0.1.8"]
               [ring "1.1.8"]]
%}

Next, we'll change the output location of the generated JavaScript to the location we specified in the index.html page (remember resources/public/ is linked to app/).

{% inline_code lang:clj project.clj
:main {
       :source-paths ["src/cljs"]
       :compiler {:output-to "resources/public/scripts/app.js"
                  :optimizations :simple
                  :pretty-print true}
       :jar true}
%}

Then we'll add a duplicate section to compile the ClojureScript tests to JavaScript.

{% inline_code lang:clj project.clj
:unit-test {
            :source-paths ["test/cljs"]
            :compiler {:output-to "test/spec/app-tests.js"
                       :optimizations :simple
                       :pretty-print true}}  
%}

The source location for the tests does not exist yet, we'll create it later. Before moving on it's a good idea to compile the ClojureScript to ensure everything is working as expected.

{% inline_code lang:console
$ lein cljsbuild once
%}

### Creating and configuring an Angular module

We'll remove the ClojureScript file created by leiningen and instead create a new file to define and configure our Angular module.

{% inline_code lang:console
$ rm src/cljs/todo/client.cljs
$ touch src/cljs/todo/app.cljs
%}

We'll start taking advantage of the macros defined in purnam. We'll also include the purnam JavaScript macros to generate raw JavaScript objects for use when defining our routes.

{% inline_code lang:clj src/cljs/todo/app.cljs
(ns todo.app
  (:use-macros [purnam.js :only [obj]]
               [purnam.angular :only [def.module def.config]]))

(def.module todoApp [])

(def.config todoApp [$routeProvider]
  (doto $routeProvider
      (.when "/" (obj :templateUrl "views/main.html" :controller "MainCtrl"))
      (.otherwise (obj :redirectTo "/"))))
%}

### Creating a controller

We'll create a controller for the view main.html, which already exists and is defined in the routes we just configured in the section above.

{% inline_code lang:console
$ mkdir src/cljs/todo/controllers
$ touch src/cljs/todo/controllers/main.cljs
%}

We next define a simple controller containing a function on the scope to retrieve the remaining todos which we are already using in the main.html template we defined above.

{% inline_code lang:clj src/cljs/todo/controllers/main.cljs
(ns todo.controllers.main
  (:require [todo.app])
  (:use [purnam.cljs :only [aset-in]])
  (:use-macros [purnam.js :only [!]]
               [purnam.angular :only [def.controller]]))

(def.controller todoApp.MainCtrl [$scope]
  (! $scope.remainingTodos (fn [] 3)))
%}

The `!` is a macro. It is used to set JavaScript objects using dot notation, which makes the ClojureScript a bit more readable when working with JavaScript. Before we get too far lets begin writing tests for the controller.

### Writing a test for a controller

Create the directory structure and a test file for the controller.

{% inline_code lang:console
$ mkdir -p test/cljs/todo/controllers
$ touch test/cljs/todo/controllers/main-tests.cljs
%}

Our first test will simply check the value we are returning from the remainingTodos function defined on our controller. We'll require the namespace we defined our controller in. We will take advantage of purnam.test to write our tests. Purnam.test defines several macros which help make the tests more readable. Purnam.test [requires the 'init' macro](http://docs.caudate.me/purnam/#init) at the top of all test files.

{% inline_code lang:clj test/cljs/todo/controllers/main-tests.cljs
(ns todo.controllers.main-tests
  (:require [todo.controllers.main])
  (:use [purnam.cljs :only [aset-in aget-in]])
  (:use-macros
   [purnam.js :only [obj]]
   [purnam.test :only [init describe it is is-not]]
   [purnam.test.angular :only [describe.controller]]))

(init)

(describe.controller
  {:doc "Testing Main Controller"
   :module todoApp
   :controller MainCtrl
   }

  (it "should have 3 default remaining todos"
      (is ($scope.remainingTodos) 3)))
%}

Let's make sure this test runs. It may be helpful at this point to auto compile the ClojureScript and auto run the tests.

{% inline_code lang:console
$ karma start karma.conf.js &
$ lein cljsbuild auto
%}

### Adding to the test

With a test in place let's go back to the main controller and add 3 default todos and change the remainingTodos functions to return the number of todos.

{% inline_code lang:clj src/cljs/todo/controllers/main.cljs
(def.controller todoApp.MainCtrl [$scope]
  (! $scope.todos (arr {:text "Learn Clojure" :done false}
                       {:text "Learn JavaScript" :done false}
                       {:text "Learn Angular" :done false})) 
  (! $scope.remainingTodos (fn []
                             (.-length $scope.todos))))
%}

We are now using an array so we will now need to include the `arr` macro in main.cljs, `[purnam.js :only [! arr]]`.

***Making changes to the application's ClojureScript source will cause leiningen to recompile the ClojureScript, if cljsbulid is run using auto. This will not cause the tests to rerun though. You must touch a ClojureScript test file first. Touching a ClojureScript test file will generate a new JavaScript test file. Karma will notice this change and rerun the tests. ***

When we created the default todos adove, in addition to the name of the todo, we added an extra property to mark whether the todo is completed or not. Let's make use of this property. We'll begin by writing a test to verify we only count the todos not complete. We'll setup our test by assigning a new list of todos with one todo marked as complete.

{% inline_code lang:clj test/cljs/todo/controllers/main-tests.cljs
(it "should filter out done todos"
    (! $scope.todos (arr {:text "Learn Clojure" :done false}
                         {:text "Learn JavaScript" :done true}
                         {:text "Learn Angular" :done false}))
    (is ($scope.remainingTodos) 2))
%}

Don't forget to include the additional macros `[purnam.js :only [obj ! arr]]` in main-tests.cljs. This test will fail. Let's fix it.

{% inline_code lang:clj src/cljs/todo/controllers/main.cljs
(! $scope.remainingTodos (fn []
                             (.-length ($scope.todos.filter
                                         (fn [v] (not v.done))))))
%}

### Viewing the application

Let's now update our template to display the list of todos as a list.

{% inline_code lang:html app/views/main.html
<div class="centered">
  <h1>Todo List</h1>
  <span>{{remainingTodos()}} remaining</span>
  <ul class="unstyled">
    <li ng-repeat="t in todos">
      <span>{{t.text}}</span>
    </li>
  </ul>
</div>
%}

There are a couple ways we can view our todo application. Since we are using grunt we can view our application by running `grunt server`. This has the benefit of auto launching our application and automatically reloading the application when we make changes. The drawback is that it only works with the client side of our application. This is sufficient for our example, since we don't have any server code. The second way we can view our application is by using Ring, `lein ring server`. Our website will then be available on the port we defined in server.clj, in our example we used port 3000. This does not have the drawback of grunt but also does not include the live reloading we benefited from when using grunt. A potential solution is to use both, run the client side of an application on one port using grunt and then run the server side of an application using Ring on another port. Since we don't have any server code we'll use grunt.

{% inline_code lang:console
$ grunt server
%}

Next, let's add a checkbox next to each todo. When clicked it will mark the todo as complete. The todo will now be displayed in a label so it can be associated to the checkbox using the $index variable belonging to the ngRepeat directive.

{% inline_code lang:html app/views/main.html
<div class="centered">
  <h1>Todo List</h1>
  <span>{{remainingTodos()}} remaining</span>
  <ul class="unstyled remaining-todos">
    <li ng-repeat="t in todos">
      <input id="item{{ $index }}" type="checkbox" ng-model=t.done>
      <label for="item{{ $index }}" ng-class="{'todo-done': t.done}">{{t.text}}
    <li>
   </ul>
</div>
%}

And we'll add some styling to align the checkbox to the left of the label and display done todos as completed by drawing a line through them.

{% inline_code lang:css app/style/main.css
.remaining-todos li input[type=checkbox] { float:left; }
.todo-done { text-decoration:line-through; color:gray; }
%}

### Conclusion

So far we have looked at creating our todo application using both leiningen as well as yeoman, in attempt to reap the benefits of both. We have seen that using Purnam makes working with JavaScript and AngularJS simpler and more readable. We are able to write tests for our application and use cljsbuild to auto compile our ClojureScript and Karma to auto run our tests, although we need to touch a test file after changing our application's source so that the tests will rerun.

At this point our todo application isn't very functional. We can display todos and mark them as complete. Next we'll look at creating filters to display todo counts, create a service for working with the list of todos and introduce functionality for adding new todos.

[Example source](https://github.com/ciwchris/purnam-angular-example)
