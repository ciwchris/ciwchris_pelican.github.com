<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Notes to self</title><link href="http://ciwchris.github.io/" rel="alternate"></link><link href="http://ciwchris.github.io/feeds/concepts.atom.xml" rel="self"></link><id>http://ciwchris.github.io/</id><updated>2014-02-17T20:48:00-08:00</updated><entry><title>Structure and Interpretation of Computer Programs: Highlighted Text</title><link href="http://ciwchris.github.io/blog/sicp-highlights.html" rel="alternate"></link><updated>2014-02-17T20:48:00-08:00</updated><author><name>Chris</name></author><id>tag:ciwchris.github.io,2014-02-17:blog/sicp-highlights.html</id><summary type="html">&lt;p&gt;Text highlighted during an initial reading of
&lt;a href="http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-10.html"&gt;Structure and Interpretation of Computer Programs&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Chapter 1&lt;/h1&gt;
&lt;p&gt;Master software engineers have the ability to organize programs so that they can be reasonably sure that the resulting processes will perform the tasks intended.&lt;/p&gt;
&lt;p&gt;The most significant of these features is the fact that Lisp descriptions of processes, called procedures, can themselves be represented and manipulated as Lisp data.&lt;/p&gt;
&lt;h2&gt;1.1&lt;/h2&gt;
&lt;p&gt;In programming, we deal with two kinds of elements: procedures and data. (Later we will discover that they are really not so distinct.)&lt;/p&gt;
&lt;p&gt;substitution model
normal-order evaluation vs applicative-order evaluation&lt;/p&gt;
&lt;p&gt;The word predicate is used for procedures that return true or false, as well as for expressions that evaluate to true or false.&lt;/p&gt;
&lt;p&gt;The contrast between function and procedure is a reflection of the general distinction between describing properties of things and describing how to do things, or, as it is sometimes referred to, the distinction between declarative knowledge and imperative knowledge.&lt;/p&gt;
&lt;p&gt;block structure
lexical scoping&lt;/p&gt;
&lt;h2&gt;1.2 (very boring chapter primarily having to do with mathematics and calculating space and operations)&lt;/h2&gt;
&lt;p&gt;linear recursive process vs linear iterative process&lt;/p&gt;
&lt;p&gt;It will execute an iterative process in constant space, even if the iterative process is described by a recursive procedure. An implementation with this property is called tail-recursive.&lt;/p&gt;
&lt;h2&gt;1.3&lt;/h2&gt;
&lt;p&gt;Procedures that manipulate procedures are called higher-order procedures.&lt;/p&gt;
&lt;p&gt;Experienced programmers know how to choose procedural formulations that are particularly perspicuous, and where useful elements of the process are exposed as separate entities that can be reused in other applications.&lt;/p&gt;
&lt;p&gt;expert programmers know how to choose the level of abstraction appropriate to their task.&lt;/p&gt;
&lt;p&gt;Lisp, unlike other common programming languages, awards procedures full first-class status. This poses challenges for efficient implementation, but the resulting gain in expressive power is enormous.&lt;/p&gt;
&lt;h1&gt;Chapter 2&lt;/h1&gt;
&lt;p&gt;The general technique of isolating the parts of a program that deal with how data objects are represented from the parts of a program that deal with how data objects are used is a powerful design methodology called data abstraction.
closure -- that the glue we use for combining data objects should allow us to combine not only primitive data objects, but compound data objects as well.&lt;/p&gt;
&lt;h2&gt;2.1&lt;/h2&gt;
&lt;p&gt;Data abstraction is a methodology that enables us to isolate how a compound data object is used from the details of how it is constructed from more primitive data objects.&lt;/p&gt;
&lt;p&gt;Data objects constructed from pairs are called list-structured data.&lt;/p&gt;
&lt;h2&gt;2.2&lt;/h2&gt;
&lt;p&gt;The word nil is a contraction of the Latin word nihil, which means ``nothing.''&lt;/p&gt;
&lt;p&gt;The difference between the two definitions is not that the computer is performing a different process (it isn't) but that we think about the process differently. In effect, map helps establish an abstraction barrier that isolates the implementation of procedures that transform lists from the details of how the elements of the list are extracted and combined.&lt;/p&gt;
&lt;p&gt;In working with compound data, we've stressed how data abstraction permits us to design programs without becoming enmeshed in the details of data representations, and how abstraction preserves for us the flexibility to experiment with alternative representations.&lt;/p&gt;
&lt;p&gt;The value of expressing programs as sequence operations is that this helps us make program designs that are modular, that is, designs that are constructed by combining relatively independent pieces.&lt;/p&gt;
&lt;p&gt;stratified design, the notion that a complex system should be structured as a sequence of levels that are described using a sequence of languages. Each level is constructed by combining parts that are regarded as primitive at that level, and the parts constructed at each level are used as primitives at the next level.&lt;/p&gt;
&lt;p&gt;Stratified design helps make programs robust, that is, it makes it likely that small changes in a specification will require correspondingly small changes in the program.&lt;/p&gt;
&lt;h2&gt;2.3&lt;/h2&gt;
&lt;p&gt;Symbolic differentiation is of special historical significance in Lisp. It was one of the motivating examples behind the development of a computer language for symbol manipulation. &lt;/p&gt;
&lt;p&gt;We can represent trees by using lists. Each node will be a list of three items: the entry at the node, the left subtree, and the right subtree.&lt;/p&gt;
&lt;p&gt;We have examined options for using lists to represent sets and have seen how the choice of representation for a data object can have a large impact on the performance of the programs that use the data.&lt;/p&gt;
&lt;p&gt;The designer can create an initial implementation using a simple, straightforward representation such as unordered lists. This will be unsuitable for the eventual system, but it can be useful in providing a ``quick and dirty'' data base with which to test the rest of the system. Later on, the data representation can be modified to be more sophisticated. If the data base is accessed in terms of abstract selectors and constructors, this change in representation will not require any changes to the rest of the system.&lt;/p&gt;
&lt;h2&gt;2.4&lt;/h2&gt;
&lt;p&gt;These data-abstraction barriers are powerful tools for controlling complexity. By isolating the underlying representations of data objects, we can divide the task of designing a large program into smaller tasks that can be performed separately. &lt;/p&gt;
&lt;p&gt;So in addition to the data-abstraction barriers that isolate representation from use, we need abstraction barriers that isolate different design choices from each other and permit different choices to coexist in a single program. &lt;/p&gt;
&lt;p&gt;Our main technique for building generic procedures will be to work in terms of data objects that have type tags, that is, data objects that include explicit information about how they are to be processed.&lt;/p&gt;
&lt;p&gt;The principle of least commitment: The abstraction barrier formed by the selectors and constructors permits us to defer to the last possible moment the choice of a concrete representation for our data objects and thus retain maximum flexibility in our system design.&lt;/p&gt;
&lt;p&gt;The general strategy of checking the type of a datum and calling an appropriate procedure is called dispatching on type.&lt;/p&gt;
&lt;p&gt;data-directed programming: Here we will implement the interface as a single procedure that looks up the combination of the operation name and argument type in the table to find the correct procedure to apply, and then applies it to the contents of the argument.&lt;/p&gt;
&lt;p&gt;message passing: An alternative implementation strategy is to decompose the table into columns and, instead of using &lt;code&gt;intelligent operations'' that dispatch on data types, to work with&lt;/code&gt;intelligent data objects'' that dispatch on operation names.&lt;/p&gt;
&lt;h2&gt;2.5&lt;/h2&gt;
&lt;p&gt;Often the different data types are not completely independent, and there may be ways by which objects of one type may be viewed as being of another type. This process is called coercion.&lt;/p&gt;
&lt;p&gt;In general, we can implement this idea by designing coercion procedures that transform an object of one type into an equivalent object of another type.&lt;/p&gt;
&lt;p&gt;hierarchy of types, in which, for example, integers are a subtype of rational numbers&lt;/p&gt;
&lt;p&gt;in which each type has at most one supertype and at most one subtype. Such a structure, called a tower,&lt;/p&gt;
&lt;h1&gt;Chapter 3&lt;/h1&gt;
&lt;p&gt;In particular, we need strategies to help us structure large systems so that they will be modular, that is, so that they can be divided ``naturally'' into coherent parts that can be separately developed and maintained.&lt;/p&gt;
&lt;p&gt;The first organizational strategy concentrates on objects, viewing a large system as a collection of distinct objects whose behaviors may change over time. An alternative organizational strategy concentrates on the streams of information that flow in the system, much as an electrical engineer views a signal-processing system.&lt;/p&gt;
&lt;p&gt;The difficulties of dealing with objects, change, and identity are a fundamental consequence of the need to grapple with time in our computational models.&lt;/p&gt;
&lt;p&gt;delayed evaluation: The stream approach can be most fully exploited when we decouple simulated time in our model from the order of the events that take place in the computer during evaluation.&lt;/p&gt;</summary><category term="sicp lisp books"></category></entry></feed>